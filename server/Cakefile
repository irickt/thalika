###
Cakefile for top-level application and its clients and servers
See template_notes.txt for general design and project layout

select on config markers eg config.FOR_SERVER
uses subproject scripts to specialize the build




fixed
fix for https://github.com/jashkenas/coffee-script/pull/2373
install coffee-script master or >1.3.3

###


console.log ""


_ = require 'underscore'
_.templateSettings =
    interpolate: /\{\{(.+?)\}\}/g
async = require "async"

require 'icing'
path = require 'path'
fs   = require 'fs'
{exec} = require 'child_process'

modulePath  = path.dirname fs.realpathSync __filename # is the location of the Cakefile
# process.cwd() is pwd of the shell where the Cakefile is (must be) run. so, same as modulePath.

config = require "./config.coffee"
forApplication = config.FOR_APPLICATION? or false
forServer = config.FOR_SERVER? or false
forBrowser = config.FOR_BROWSER? or false
if not (forApplication or forServer or forBrowser)
    console.log "Must be one of APPLICATION, SERVER, or BROWSER"
    process.exit 1
if (forApplication and forServer) or (forApplication and forBrowser) or (forServer and forBrowser)
    console.log "Must be only one of APPLICATION, SERVER, or BROWSER"
    process.exit 1

if forApplication then console.log "WHOLE APPLICATION", config.TITLE
if forServer then console.log "SERVER", config.TITLE
if forBrowser then console.log "BROWSER", config.TITLE

# later, these will be generated by inspecting the components
# note, glob brace expansion depends on an icing patch
globPath = "" # don't try to watch everything!
# globPath = if forApplication then "{client/,server/,}" else ""
components = if forApplication then ["client/", "server/"] else []

# given an array of paths some of which start with componentPaths, and the rest start with ""
# return an object of arrays where a key is a componentPath and the array contains the associated paths
# note, this is from a reverted experiment, too complex for the way this currently works.
pathObject = (components, paths) ->
    cPaths = {}
    _.forEach components, (component) ->
        cPaths[component] = _.filter paths, (path) -> path.indexOf(component) == 0
    cPaths[""] = _.filter paths, (path) -> _.all components, (component) -> path.indexOf(component) == -1
    cPaths

componentPaths = (paths) ->
    pathObject components, paths
# filesObject = componentPaths this.modifiedPrereqs


###
iterate over an array of source files: `sources`
use regex to get the compiled output file name: `ofile`
call the compiler using a template. (better, pipe to the output file so the cmd format is consistent.)

this is typically used twice for each task:
  once to list all the possible output files
  once to compile the actually changed files

FIX patch icing to add `settings` to the recipe. add settings to context for recipe and outputs.
    then settings.regexes can be used in both.
    see runRecipeContext and ruleGraph.rule, respectively
    currently, both are passed the options array containing command-line options
FIX add a third regex for name if needed
    tname = infile.replace regexes[0], regexes[2]
###
targetedFiles = (task, sourceFiles, regexes, compiler) ->
    cmdTemplate =
        coffee: "cat {{ data.infile }} | coffee -sc > {{ data.outfile }}"
        lessc: "lessc {{ data.infile }} {{ data.outfile }}"
        dustc: "dustc --name={{data.tname}} {{ data.infile }} {{ data.outfile }}"
    for infile in sourceFiles
        outfile = infile.replace regexes[0], regexes[1]
        tname = if infile.indexOf('.dust.html') > 0 then path.basename(infile, ".dust.html") else ""
        #console.log task.target, infile, outfile
        if compiler
            tmpl = _.template cmdTemplate[compiler], null, {variable: 'data'} # 'data' is an efficiency tweak
            #console.log task.target, compiler, infile, outfile
            # add the output directory if missing
            if !fs.exists path.dirname outfile
                mkdirp = require "mkdirp"
                mkdirp.sync path.dirname outfile
            task.exec [ tmpl {infile: infile, tname: tname, outfile: outfile} ] # does the cmds sequentially
            continue # no return value needed for compile phase
        outfile # returns [ofile1, ...] # a coffeescript trick



task 'version', 'Version number Use cake -v version for more info. ', (options) ->
    packageData = require "./package.coffee"
    if options.verbose
        console.log "version: ", packageData.version
        console.log "name: ", packageData.name
        console.log "description: ", packageData.description
    else
        console.log packageData.version


task 'dev', 'Open shells. Mac and iTerm2 specific.', (options) ->
    # for whom, session per component, editor
    target = path.join modulePath, "scripts/devenv.coffee"
    if fs.existsSync target
        exec "coffee #{ target } #{ modulePath }"
        # starts the dev server in a shell


task 'compile:config', 'Convert package.coffee to package.json',
    [globPath + 'package.coffee', globPath + 'config.coffee'],
        outputs: ->
            #console.log "outputs", this.filePrereqs
            regexes = [ /(.*)([package|config]).coffee/, "$1$2.json" ]
            targetedFiles this, this.filePrereqs, regexes
        recipe: ->
            #console.log "recipe", this.modifiedPrereqs
            files = this.modifiedPrereqs
            if forApplication
                configPath = "scripts/" # no lib, application works in coffee, in scripts/
            else if forServer
                configPath = "lib/js/" # dup in src? so server can run in coffee
            else if forBrowser
                configPath = "lib/js/" # to be bundled

            # config.coffee depends on package.coffee. make sure it is in the list.
            # or use the dep graph, separate to two tasks
            addFiles = []
            for file in files
                addFiles.push file.replace "package.coffee", "config.coffee"
            files = _.union files, addFiles
            console.log "compile:config", files
            for file in files
                data = require "./#{file}"
                target = file.replace("package.coffee", "package.json")
                             .replace "config.coffee", path.join configPath, "config.json"
                #console.log target, file, data
                fs.writeFileSync (path.join modulePath, target), (JSON.stringify data, null, 4)
            this.finished()


task 'compile:code', 'coffee ... src/code/ -> lib/js/',
    [globPath + 'src/code/**/*.coffee'],
        outputs: ->
            #console.log "outputs", this.filePrereqs
            regexes = [ /(.*)src\/code\/(.*).coffee/,"$1lib/js/$2.js" ]
            targetedFiles this, this.filePrereqs, regexes
        recipe: ->
            console.log "compile:code", "\n", this.modifiedPrereqs
            regexes = [ /(.*)src\/code\/(.*).coffee/,"$1lib/js/$2.js" ]
            targetedFiles this, this.modifiedPrereqs, regexes, "coffee"
            this.finished()

task 'bundle:code', 'bundle compiled js using bundleCode.coffee',
    ['outputs(compile:code)'],
        outputs: ->
            if forBrowser then ["lib/bundle.js"] else []
        recipe: ->
            console.log "bundle:code", "\n", this.modifiedPrereqs
            if forBrowser
                # components = _.keys componentPaths this.modifiedPrereqs
                components = [""]
                _.each components, (component) ->
                    bundler = path.join modulePath, component, "scripts", "bundleCode.coffee"
                    #console.log bundler
                    if fs.existsSync bundler
                        console.log "run", bundler
                        exec bundler # bundler uses its own path
            this.finished()


task 'compile:tmpl', 'dust   ... src/tmpl/ -> lib/tmpl/',
    [globPath + 'src/tmpl/*.dust.html'],
        outputs: ->
            #console.log "outputs", this.filePrereqs
            regexes = [ /(.*)src\/tmpl\/(.*).dust.html/ , "$1lib/tmpl/$2.dust.js" ]
            targetedFiles this, this.filePrereqs, regexes
        recipe: ->
            console.log "compile:tmpl", "\n", this.modifiedPrereqs
            regexes = [ /(.*)src\/tmpl\/(.*).dust.html/ , "$1lib/tmpl/$2.dust.js" ]
            targetedFiles this, this.modifiedPrereqs, regexes, "dustc"
            this.finished()

task 'bundle:tmpl', 'bundle compiled tmpl using bundleTemplates.coffee',
    ['outputs(compile:tmpl)'],
        outputs: ->
            if forBrowser then ["lib/bundleTemplates.js"] else []
        recipe: ->
            console.log "bundle:tmpl", "\n", this.modifiedPrereqs
            if forBrowser
                # components = _.keys componentPaths this.modifiedPrereqs
                components = [""]
                _.forEach components, (component) ->
                    bundler = path.join modulePath, component, "scripts", "bundleTemplates.coffee"
                    if fs.existsSync bundler
                        console.log "run", bundler
                        exec bundler # bundler uses its own path
            this.finished()


task 'compile:style', 'less   ... src/style/ -> lib/css/',
    [globPath + 'src/style/*.less'],
        outputs: (options) ->
            #console.log "outputs", this.filePrereqs
            regexes = [ /(.*)src\/style\/(.*).less/, "$1lib/css/$2.css" ]
            targetedFiles this, this.filePrereqs, regexes
        recipe: ->
            console.log "compile:style", "\n", this.modifiedPrereqs
            regexes = [ /(.*)src\/style\/(.*).less/, "$1lib/css/$2.css" ]
            targetedFiles this, this.modifiedPrereqs, regexes, "lessc"
            this.finished()

task 'compile:tests', 'coffee ... test/ -> test/js/',
    [globPath + 'test/*.coffee'],
        outputs: (options) ->
            regexes = [ /(.*)test\/(.*).coffee/,"$1test/js/$2.js" ]
            targetedFiles this, this.filePrereqs, regexes
        recipe: ->
            console.log "compile:tests", "\n", this.modifiedPrereqs
            regexes = [ /(.*)test\/(.*).coffee/,"$1test/js/$2.js" ]
            targetedFiles this, this.modifiedPrereqs, regexes, "coffee"
            this.finished()

task 'compile:source', 'Compile code, templates, styles, and tests',
    [
        'outputs(compile:code)'
        'outputs(compile:tmpl)'
        'outputs(compile:style)'
        'outputs(compile:tests)'
    ],
        outputs: ->
            []
        recipe: ->
            this.finished()


task 'build', 'Build client or server. This does all the above.',
    [
        'outputs(compile:config)'
        'outputs(compile:source)'
        'outputs(bundle:code)'
        'outputs(bundle:tmpl)'
    ], (options) -> # equivalent to {recipe: (options) -> ..., outputs: []}
            #if forApplication
                # child processes to build components
            #else if forBrowser
            #else if forServer

            # this.finished()

task 'test', 'Run tests',
    ['task(build)'], (options) -> # equivalent to {recipe: (options) -> ..., outputs: []}
        #if forApplication
            # child processes to test components
        #else if forBrowser
        #else if forServer

        # v = options.verbose
        command = "./node_modules/.bin/buster-test --config test/js/config-tests.js"
        # depends on npm link. or use other project or env alias, or for global install ...
        #command = "/usr/local/lib/node_modules/buster/bin/buster-test --config test/config-tests.js -e browser"
        this.exec [
            command
            ]



###
switch for dev, deploy1, deploy2, ...
config for server
    host:port # env from script
    static file path # env form script
config for application
    local deploy repo # script
    deploy cmd/env # script
    install hook scripts eg npm test
###
option '-t', '--target [TARGET]', 'Deploy to target host eg cake --t heroku deploy'

task 'deploy', 'Deploy to host',
    [], (taskOptions) ->
        if not forApplication
            console.error "Deploy from Application"
            # for applications with multiple services ...
            return

        actions = require "./scripts/buildRepoForHeroku.coffee"
        deployInfo =
            target: taskOptions.target
            description: "deploy commit message"
            deployRepoPath: path.resolve "../deploy"

        deployCommands =
            heroku: """
                    git add #{ deployInfo.deployRepoPath }
                    git push heroku master
                    heroku config:set KEY1=VALUE1 [KEY2=VALUE2 ...] (if changed)
                """
        if taskOptions.target not in _.keys deployCommands
           this.failed "Set a target eg  cake --target heroku deploy"
        deployCommands = deployCommands[taskOptions.target].split "\n"

        env =
            cwd: modulePath

        commands = []
        commands.push (cb) ->
                actions.buildDeployRepo (err, items) ->
                    cb err, items
        commands.push ( (cb) ->
                exec cmd, env, (err, stdout, stderr) ->
                    cb err, stdout
                ) for cmd in deployCommands

        # icing this.exec does shell commands sequentially, but not internal synchronous calls.
        # use async so they can be mixed.
        async.series commands, (err, results) ->
                console.log err, results








###
snippets

# option '-o', '--output [DIR]', 'directory for compiled code'
# option '-t','--tap','Run tests with tap output'


target = path.join modulePath, 'lib/tmpl/templates.dust.js'
if fs.existsSync target
    fs.unlinkSync target



https://github.com/jprichardson/node-fs-extra/
https://github.com/jeremyruppel/frosting
https://github.com/AvianFlu/ncp




# scripts can figure out where the are and adapt
# cmds need path and env set up

# spawn streams stdout, exec buffers until done and does callback
deploySh = spawn "sh", ["some cmd"],
    cwd: process.env.HOME + "/subproject"
    env: _.extend process.env,
        PATH: "full path to ./node_modules/.bin" + ":" + process.env.PATH


# the hard way
exec "coffee -o config/js/ -c config/package.coffee", (error) =>
    packageData = require "./config/js/package.js" # the complied file
    packageJsonPath = path.join modulePath, 'package.json'
    try
        fs.writeFileSync packageJsonPath, (JSON.stringify packageData, null, 4)
        fs.unlinkSync path.join modulePath, 'config/js/package.js'
        this.finished()
    catch error
        this.failed error

###
